use crate::ast::*;

grammar;

use std::str::FromStr;

match {
  // 跳过空白符和注释
    r"\s*" => {},
    r"//[^\n\r]*[\n\r]*" => {},
  // 剩下的情况采用默认方式处理
    _
}

pub Program: Program = {
    "main" "(" ")" Block => Program{main:<>}
};

Block: BlockStatement = {
    "{" Statements "}" => BlockStatement{statements:<>}
};

Statements: Vec<Statement> = {
    => Vec::new(),
    <statement:Statement> ";" <statements:Statements> => {
        let mut stmts = vec![statement];
        stmts.extend(statements.into_iter());
        stmts
    },
};

Statement: Statement = {
    Assignment => Statement::Assignment(<>),
    Conditional => Statement::Conditional(<>),
    Loop => Statement::LoopStatement(<>),
};

Assignment: AssignmentStatement = {
    <i:ID> "==" <expr:Expr> => AssignmentStatement {id:i.to_string(),expression:expr},
};

Conditional: ConditionalStatement = {
    "if" "(" <expr:Expr> ")" <block:Block> => ConditionalStatement {condition:expr,block:block},
};

Loop: LoopStatement = {
    "while" "(" <expr:Expr> ")" <b:Block> => LoopStatement{condition:expr,block:b},
};

Expr: Expression = {
    Term => Expression::Term(<>),
    <e:Expr> "+" <t:Term> => Expression::ASOP(AddandSubOp{
        left:Box::new(e),
        opcode:Opcode::Add,
        right:Box::new(t),
    }),
    <e:Expr> "-" <t:Term> => Expression::ASOP(AddandSubOp{
        left:Box::new(e),
        opcode:Opcode::Sub,
        right:Box::new(t),
    }),
    <e:Expr> "<" <t:Expr> => Expression::BinaryExpr(BinaryExpression{
        left:Box::new(e),
        operator:RelationalOperator::LessThan,
        right:Box::new(t),
    }),
    <e:Expr> "<=" <t:Expr> => Expression::BinaryExpr(BinaryExpression{
        left:Box::new(e),
        operator:RelationalOperator::LessEqual,
        right:Box::new(t),
    }),
    <e:Expr> ">" <t:Expr> => Expression::BinaryExpr(BinaryExpression{
        left:Box::new(e),
        operator:RelationalOperator::GreaterThan,
        right:Box::new(t),
    }),
    <e:Expr> ">=" <t:Expr> => Expression::BinaryExpr(BinaryExpression{
        left:Box::new(e),
        operator:RelationalOperator::GreaterEqual,
        right:Box::new(t),
    }),
    <e:Expr> "==" <t:Expr> => Expression::BinaryExpr(BinaryExpression{
        left:Box::new(e),
        operator:RelationalOperator::Equal,
        right:Box::new(t),
    }),
    <e:Expr> "!=" <t:Expr> => Expression::BinaryExpr(BinaryExpression{
        left:Box::new(e),
        operator:RelationalOperator::NotEqual,
        right:Box::new(t),
    }),
};

Term: Term = {
    Factor => Term::Factor(<>),
    <t:Term> "*" <f:Factor> => Term::Multiply(Box::new(t),Box::new(f)),
    <t:Term> "/" <f:Factor> => Term::Divide(Box::new(t),Box::new(f)),
};

Factor: Factor = {
    ID => Factor::Identifier(<>.to_string()),
    NUM => Factor::Number(i64::from_str(<>).unwrap()),
    "(" Expr ")" => Factor::Expr(Box::new(<>)),
};

ID: String = r"[a-zA-Z_][a-zA-Z0-9_]*";
NUM: String = r"[0-9]+";